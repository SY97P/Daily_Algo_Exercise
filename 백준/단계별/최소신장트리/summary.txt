⚛️ 백준

	🪄 최소 신장 트리

	* 상근이의 여행
	    - ST (스패닝 트리)
	    - 모든 정점이 연결된 사이클 없는 트리
	    - Prim, Kruskal 알고리즘 모두 사용

	    * Prim 알고리즘 (배열 : O(EV) / 힙 : O(E log V))
	        1. 임의의 점 하나를 MST에 추가
	        2. MST에 포함된 원소와 아닌 원소 간 간선 중에서 최소 간선을 선택해 MST에 추가
	        3. 모든 정점이 MST에 포함되도록 반복

        * Kruskal 알고리즘 (배열 : O(EV) / 힙 : O(E log V))
            1. 모든 간선을 오름차순으로 정렬
            2. MST 내부 원소끼리 사이클이 발생하지 않는 최소 간선을 선택해 추가
                -> 사이클 여부 판단 : 유니온-파인드
            3. 모든 정점이 MST에 포함되도록 반복

    * 최소 스패닝 트리
        - MST (최소신장트리)
        - 간선 합이 최소인 모든 정점이 연결된 사이클 없는 트리
        - Prim, Kruskal 알고리즘 모두 사용
        - Python3, Java11 제출

    * 별자리 만들기
        - 입력으로 좌표가 주어짐
        - 좌표와 해당 좌표정점의 인덱스를 이용해서 간선을 만들어 해결

    * 우주신과의 교감
        - 이미 지나간 간선에 대한 입력이 들어오므로 크루스칼 알고리즘이 유리
        - 시간초과 해결
            - 입력 시 이미 지나간 간선에 대한 검사 수행 X
            - 유니온-파인드로 이미 지나간 간선에 대해서 mst를 갱신한 뒤에 나머지 연산 수행

    * 전력난
        - (u, v, c) 쌍으로 주어졌으므로, 입력 포맷을 그대로 이용할 수 있는 크루스칼 알고리즘 사용
        - EOF 문자가 주어진 무한입력이므로 입출력 영역을 신경써야 함.

    * 다리 만들기2
        - 2차원 배열에 섬과 바다 존재. 모든 섬을 잇는 경로가 있는지, 있으면 최소로 필요한 다리 길이가 얼마인지 구하는 문제
        1. 각 섬에 고유한 번호 부여 (DFS 영역 지정하기;number -> matrix)
        2. 각 섬 사이의 거리 구하기 (DFS;dist -> adj)
        3. 모든 섬을 잇는 MST 구하기 (prim;Prim -> visited)
        4. 모든 섬을 연결할 수 있는지 구하기 (visited)
        - 1% 오답 : 섬 사이 거리 구할 때 양방향 그래프가 되도록 adj에 바인딩하지 않았을 때 (MST 최적해 보장 불가)
        - 4% 오답 : 모든 섬을 이을 수 있는지 제대로 확인하지 않았을 때 (MST 구성원을 확인할 수 있는 Prim 사용 권장)