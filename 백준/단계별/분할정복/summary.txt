⚛️ 백준

	🪄 분할정복 (Divide & Conquer)

	* 색종이 만들기
	    - 쿼드 트리 (Quad Tree) < 분할정복
	    - 하나의 화면을 4개의 작은 화면으로 분할하여 정복
	    - 가로/세로 길이가 각각 짝수인지 홀수인지에 따라서 분할된 길이가 달라져야 함.

    * 쿼드트리
        - 쿼드트리(Quad Tree) < 분할정복
        - 분할정복 전/후에 "(", ")"를 출력
        - 1, 2, 3, 4분면 순서대로 재귀호출될 수 있도록 조정

    * 종이의 개수
        - 쿼드트리 -> 에니아트리(9개) < 분할정복
        - 홀짝 구분 없음 n = 3^k

    * 곱셈
        - 분할정복
        - dp 사용하면 메모리초과 발생
        - A^b = (A^(b/2))^2 임을 이용

    * 이항계수 3
        - 분할정복
        - 페르마의 소정리 (모듈러 곱셈 역원; 조합론)
        - a^t mod t == a mod t
        - a^(t-1) mod t == 1 mod t
        - a^(t-2) mod t == a^-1 mod t
        - a^(t-2) 를 분할정복으로 구함
        - 팩토리얼은 구할 때마다 모듈러로 결과 도출 후 이용

    * 행렬곱셈
        - 분할정복 (이렇게 푼게 맞는지는 모르겠음 -> 다른 사람도 그냥 이렇게 품)
        - 행렬 축을 뒤바꾸는 코드
            return list(zip(*mat_b))

    * 행렬제곱
        - 행렬제곱할 때는 순서가 중요하지 않음. (A*A)*A == A*(A*A)
        - (mod 1000) 을 신경써야 함.
            1. 초기 행렬 입력 받을 때 (원소값이 1000 이상일 때 예외처리)
            2. 행렬 원소 구할 때 (multiply 함수)

    * 피보나치수 6
        - 분할정복 > 행렬제곱
        - Un = A^n * U0 점화식 도출 가능
        - ( F(n+2) ) = ( 1 1 ) ( F(n+1) )
        - ( F(n+1) ) = ( 1 0 ) ( F(n)   )
