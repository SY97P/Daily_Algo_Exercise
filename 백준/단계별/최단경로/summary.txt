⚛️ 백준

	🪄 최단경로 

	* 최단경로
		- 다익스트라 알고리즘
		- 주어진 노드로부터 다른 모든 노드로의 최단거리 구하는 문제
		- 파이썬은 BFS로 구하는게 이득임. 
		- 4% 메모리 초과 : 간선 데이터가 방대할 경우 인접행렬로 구현하면 S(V^2)의 공간복잡도가 되므로 메모리 초과 발생 (python3 < pypy3 메모리초과 발생 가능성)
		- 4% 시간초과 : input() 함수 -> sys.stdin.readline() 함수 사용 (그냥 다익스트라 문제가 나오면 sys 사용하도록.)
		- 60% 시간초과 
			1. 출발점, 도착점이 중복된 간선이 여러개 있을 수 있음. 
			2. 이걸 전처리하려고 하면 그 처리과정에서 O(n^2)의 최악 시간복잡도가 발생할 수 있음. 
			3. 어차피 dp 이용해서 dp보다 작은 값이 아닌 이상 heapq에 넣어 연산 자체를 하지 않으므로 전처리 과정을 생략


	* 특정한 최단 경로
		- 다익스트라 알고리즘 (힙큐, DP)
		- 기존 다익스트라와 차이점
			1. 반드시 방문해야 할 정점 두 개 존재.
			2. 이미 방문했던 정점과 간선을 중복으로 사용할 수 있음. 
		- 해결법 
			1. 시작점에서 도착점의 문제를 분할정복
				-> 시작점~경유지1 + 경유지1~경유지2 + 경유지2~도착점
				-> 시작점~경유지2 + 경유지1~경유지2 + 경유지1~도착점
			2. 두 방문점 중 어딜 먼저 가느냐에 따라서 답이 달라지므로 두 경우의 수 중 최소값을 선택

	* 미확인 도착지
		- 다익스트라 알고리즘 (힙큐, DP)
		- 한 번의 다익스트라 적용으로 전체 문제를 풀 수 있음.
		- 목적지까지 최단경로가 여러개일 경우
			-> g-h 구간 이외의 최단경로는 모두 무의미하므로 g-h 구간 가중치 입출력 시 비용에 0.1 (입력 데이터는 자연수)를 제한 후 인접리스트에 저장
			-> 실제로는 목적지까지 최단경로가 여러개인 경우에도 g-h 구간을 먼저 다익스트라 알고리즘으로 탐색하기 때문에 다른 경로를 고려할 필요가 없어짐
			-> g-h는 0.1을 감산했기 때문에 해당 구간을 지나는 모든 목적지로의 최단경로 비용 합은 계속 float(실수)형일 것임
			-> 따라서 목적지 DP값이 float('inf') 초기값이 아니면서 type이 float이라면 g-h 구간을 지나온 도달가능한 목적지라는 의미임.

	* 타임머신
		벨만-포드 알고리즘 (Bellman-Ford Algorithm)
		- 시작점~도착점 최단경로 구하는 문제
		- 힙큐x, DP o, 반복문(V*E) 사용
		- 다익스트라 알고리즘과의 차이점
			- 시간복잡도 : 다익스트라( O(E log V) ) < 벨만포드( O(V*E) )
			- 음수 간선 가중치가 있는 경우에도 최적해 도출 가능 (다익스트라는 불가능)
			- 음수 순환 감지 가능 (다익스트라는 음수 순환 있는 경우 무한루프에 빠짐)
		- 기본로직
			1. 정점의 수 만큼 반복
			2. 매 정점마다 간선정보를 순회하면서 dp값 갱신
			3. 마지막 정점 순회 중 dp값이 갱신되면 음수순환 존재 (갱신되지 않으면 음수순환 부재)

	* 운동
		- 플로이드 와샬 알고리즘 (Floyd-Warshall Algorithm)
			- 반복문 사용 (DFS, BFS 사용 X)
			- 경유지 개념 차용 (경유지 > 시작점 > 도착점 반복문)
			- 분할정복 (d[s][e] = min(d[s][e], d[s][w] + d[w][e]))
			- 인접행렬 필요 없음 (그냥 DP에 넣어도 됨)
		- 사이클 필요 (시작점으로 돌아와야 함)
			- 구한 DP값을 이용
			- d[i][j] + d[j][i] 가 최소인 값 반환
			- d[i][j] + d[j][i] 가 초기값(INF)인 경우 경로 없음으로 -1 반환
			