⚛️ 백준

	🪄 문자열 알고리즘1
	- KMP 알고리즘
	- 트라이 자료구조

	* 찾기
	    - KMP 알고리즘 기본 문제
	    1. P의 j 인덱스 이전에 같은 글자가 나온 위치를 저장하는 pi 리스트 생성
	        - p[i] == p[j] -> j+=1, pi[i]=j
        2. T의 글자와 P, pi를 이용해서 답을 구함.
        - T, P를 입력받을때 strip을 사용할 경우 문자열 양단 공백이 사라지므로 사용하지 말 것.

    * 광고
        - Failure Function 문제 (pi 배열 구하는 문제)
        - 현재 인덱스의 글자가 나올 때까지의 패턴과 일치하는 패턴을 가진 이전 인덱스를 저장하는 pi 배열
            - if (j>0 and p[i] != p[j]) then j = pi[j-1]
            - 현재 글자끼리 일치하지 않으면 이전에 일치했던 패턴으로 이동해 다시 확인
            - if (p[i] == p[j]) then (j += 1 and pi[i] = j)
            - 현재 글자끼리 일치하면 현재 인덱스가 현재 패턴의 마지막 위치가 됨.

    * 개미굴
        - 트라이 구조 알아보기
        - 가짜 트라이 구조로 구현
            - 문자열의 문자 하나씩 노드 생성하여 구조 생성하는 것이 아니라, 문자열 하나당 노드 하나씩으로 구조 생성
            - 문자열이 트라이 구조에 있는지 확인하는 과정을 생략하고(find 메소드 없음), 트라이에 문자열 리스트를 무조건 추가(insert 메소드만 존재)
        - Trie 클래스 구현
            - __init__ : head
            - insert : 문자열 리스트(먹이 리스트) 추가
            - print : 트라이구조 출력 -> DFS 함수 호출

	* 전화번호 목록
		- 전화번호 목록이 주어졌을때 모든 전화번호의 prefix가 서로 겹치지 않는지 여부 판별
		- Trie 클래스의 find 메소드로 prefix를 비교할 때 매번 현재 prefix가 다른 전화번호 문자열의 마지막인지 여부를 판별, 또한 현재 노드가 문자열의 마지막일 때 자신의 문자열을 가지고 있지 않아야 prefix가 겹치게 됨. 
		- 문제를 풀기 위한 핵심은 find 메소드에 모두 있음.

    * 문자열 집합
        - Trie 자료구조 방식
            - n개 문자열 insert
            - m개 문자열 find
        - Map 방식
            - n개 문자열 map 추가
            - m개 문자열 map 검색