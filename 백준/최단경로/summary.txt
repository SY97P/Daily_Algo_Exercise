백준

	최단경로 

	* 최단경로
		- 다익스트라 알고리즘
		- 주어진 노드로부터 다른 모든 노드로의 최단거리 구하는 문제
		- 파이썬은 BFS로 구하는게 이득임. 
		- 4% 메모리 초과 : 간선 데이터가 방대할 경우 인접행렬로 구현하면 S(V^2)의 공간복잡도가 되므로 메모리 초과 발생 (python3 < pypy3 메모리초과 발생 가능성)
		- 4% 시간초과 : input() 함수 -> sys.stdin.readline() 함수 사용 (그냥 다익스트라 문제가 나오면 sys 사용하도록.)
		- 60% 시간초과 
			1. 출발점, 도착점이 중복된 간선이 여러개 있을 수 있음. 
			2. 이걸 전처리하려고 하면 그 처리과정에서 O(n^2)의 최악 시간복잡도가 발생할 수 있음. 
			3. 어차피 dp 이용해서 dp보다 작은 값이 아닌 이상 heapq에 넣어 연산 자체를 하지 않으므로 전처리 과정을 생략


	* 특정한 최단 경로
		- 다익스트라 알고리즘 (힙큐, DP)
		- 기존 다익스트라와 차이점
			1. 반드시 방문해야 할 정점 두 개 존재.
			2. 이미 방문했던 정점과 간선을 중복으로 사용할 수 있음. 
		- 해결법 
			1. 시작점에서 도착점의 문제를 분할정복
				-> 시작점~경유지1 + 경유지1~경유지2 + 경유지2~도착점
				-> 시작점~경유지2 + 경유지1~경유지2 + 경유지1~도착점
			2. 두 방문점 중 어딜 먼저 가느냐에 따라서 답이 달라지므로 두 경우의 수 중 최소값을 선택

	* 미확인 도착지
		- 다익스트라 알고리즘 (힙큐, DP)
		- 한 번의 다익스트라 적용으로 전체 문제를 풀 수 있음.
		- 목적지까지 최단경로가 여러개일 경우
			-> g-h 구간 이외의 최단경로는 모두 무의미하므로 g-h 구간 가중치 입출력 시 비용에 0.1 (입력 데이터는 자연수)를 제한 후 인접리스트에 저장
			-> 실제로는 목적지까지 최단경로가 여러개인 경우에도 g-h 구간을 먼저 다익스트라 알고리즘으로 탐색하기 때문에 다른 경로를 고려할 필요가 없어짐
			-> g-h는 0.1을 감산했기 때문에 해당 구간을 지나는 모든 목적지로의 최단경로 비용 합은 계속 float(실수)형일 것임
			-> 따라서 목적지 DP값이 float('inf') 초기값이 아니면서 type이 float이라면 g-h 구간을 지나온 도달가능한 목적지라는 의미임.
		