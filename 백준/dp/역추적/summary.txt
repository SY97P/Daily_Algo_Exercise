⚛️ 백준

	🪄 동적 계획법과 최단거리 역추적

	* 1로 만들기 2
		- /3, /2 -1 세 개의 연산을 이용해 1을 만들 때 필요한 최소 연산횟수 구하는 문제
		- 이번엔 n에서 내려가는 게 아니라, 1에서 연산을 거꾸로 하는 방식으로 구현
		- 최소값 갱신 시 현재까지의 경로를 추가하는 방식으로 역추적 경로 출력

	* 가장 긴 증가하는 부분수열4
		- 현재 값 이전 위치의 값을 가까운 순서대로 탐색하면서 처음으로 현재 값보다 낮은 수열값의 dp값 + 1과 자신의 dp값을 비교
		- 비교 후 dp[i] < dp[j] + 1 이면, dp 갱신 및 경로 갱신
		- LIS는 dp 중간에 최장길이가 나올 수 있으므로, 최대값 탐색 중개변수 maxLen, index를 두어 활용

	* 가장 긴 증가하는 부분수열5
		- n의 범위가 1,000,000까지므로 dp를 이용한 O(n^2)으로는 시간 내에 답을 구할 수 없음.
		- lis를 이용한 이분탐색 방법으로 풀어야 O(n log n)의 시간복잡도로 문제 해결이 가능함.
		- 다만 lis를 이용한 이분탐색 방법으로는 lis가 정답임을 보장할 수 없음. 
		- 따라서 역추적에 사용할 lis_index 리스트를 따로 생성해서 써야함. 
		- lis_index[i] = [i번째 수열이 lis에 들어갈 위치, i번째 수열]
		- 최종적으로 구해진 lis 배열의 길이 - 1 (lis의 가장 마지막 index)에서 시작해서 0이 될 때까지 역추적해서 정답 경로를 출력

	* LCS 2
		- a[i] == b[j] -> dp[i][j] = dp[i-1][j-1] + 1
		- a[i] != b[j] -> dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i][j])
		- dp[-1][-1] 부터 좌측, 상측, 대각선 확인하면서 DFS로 이동
		- 대각선 방향 DFS 이동 시 현재 글자 경로에 추가 
		- 최종 산출된 경로 리스트를 거꾸로 출력
		- 다른 풀이?
			- 글자가 같아서 dp[i][j] = dp[i-1][j-1] + 1 해주는 부분에 경로를 저장하도록 하는 방식도 써봄
			- 근데 이렇게 되면 실질경로가 아닌 곳도 추가하게 됨.
			- 중복되지 않게 처리하면 되겠지만 귀찮으니 나중에 시간초과가 문제가 되면 써보는 게 좋을 듯. 

	* 경찰차
		- 끝끝내 못 풀겠음
		- 강해져서 돌아오겠음.

	* 숨바꼭질 4
		- d[n] : n까지 오는데 걸리는 최소 시간
		- d[n] = min(d[n-1], d[n+1], d[n//2]) + 1
		- d[n] 값이 변하면 주변에 다른 값에도 영향을 주어야 함.
		- 뒤로 가는 방법은 x-1 밖에 없다는 걸 기억해. 제발.