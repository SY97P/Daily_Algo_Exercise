⚛️ 백준

	🪄 동적 계획법과 최단거리 역추적

	* 1로 만들기 2
		- /3, /2 -1 세 개의 연산을 이용해 1을 만들 때 필요한 최소 연산횟수 구하는 문제
		- 이번엔 n에서 내려가는 게 아니라, 1에서 연산을 거꾸로 하는 방식으로 구현
		- 최소값 갱신 시 현재까지의 경로를 추가하는 방식으로 역추적 경로 출력

	* 가장 긴 증가하는 부분수열4
		- 현재 값 이전 위치의 값을 가까운 순서대로 탐색하면서 처음으로 현재 값보다 낮은 수열값의 dp값 + 1과 자신의 dp값을 비교
		- 비교 후 dp[i] < dp[j] + 1 이면, dp 갱신 및 경로 갱신
		- LIS는 dp 중간에 최장길이가 나올 수 있으므로, 최대값 탐색 중개변수 maxLen, index를 두어 활용

	* 가장 긴 증가하는 부분수열5
		- n의 범위가 1,000,000까지므로 dp를 이용한 O(n^2)으로는 시간 내에 답을 구할 수 없음.
		- lis를 이용한 이분탐색 방법으로 풀어야 O(n log n)의 시간복잡도로 문제 해결이 가능함.
		- 다만 lis를 이용한 이분탐색 방법으로는 lis가 정답임을 보장할 수 없음. 
		- 따라서 역추적에 사용할 lis_index 리스트를 따로 생성해서 써야함. 
		- lis_index[i] = [i번째 수열이 lis에 들어갈 위치, i번째 수열]
		- 최종적으로 구해진 lis 배열의 길이 - 1 (lis의 가장 마지막 index)에서 시작해서 0이 될 때까지 역추적해서 정답 경로를 출력
