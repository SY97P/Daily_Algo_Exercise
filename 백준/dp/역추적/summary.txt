⚛️ 백준

	🪄 동적 계획법과 최단거리 역추적

	* 1로 만들기 2
		- /3, /2 -1 세 개의 연산을 이용해 1을 만들 때 필요한 최소 연산횟수 구하는 문제
		- 이번엔 n에서 내려가는 게 아니라, 1에서 연산을 거꾸로 하는 방식으로 구현
		- 최소값 갱신 시 현재까지의 경로를 추가하는 방식으로 역추적 경로 출력

	* 가장 긴 증가하는 부분수열4
		- 현재 값 이전 위치의 값을 가까운 순서대로 탐색하면서 처음으로 현재 값보다 낮은 수열값의 dp값 + 1과 자신의 dp값을 비교
		- 비교 후 dp[i] < dp[j] + 1 이면, dp 갱신 및 경로 갱신
		- LIS는 dp 중간에 최장길이가 나올 수 있으므로, 최대값 탐색 중개변수 maxLen, index를 두어 활용

	* 가장 긴 증가하는 부분수열5
		- n의 범위가 1,000,000까지므로 dp를 이용한 O(n^2)으로는 시간 내에 답을 구할 수 없음.
		- lis를 이용한 이분탐색 방법으로 풀어야 O(n log n)의 시간복잡도로 문제 해결이 가능함.
		- 다만 lis를 이용한 이분탐색 방법으로는 lis가 정답임을 보장할 수 없음. 
		- 따라서 역추적에 사용할 lis_index 리스트를 따로 생성해서 써야함. 
		- lis_index[i] = [i번째 수열이 lis에 들어갈 위치, i번째 수열]
		- 최종적으로 구해진 lis 배열의 길이 - 1 (lis의 가장 마지막 index)에서 시작해서 0이 될 때까지 역추적해서 정답 경로를 출력

	* LCS 2
		- a[i] == b[j] -> dp[i][j] = dp[i-1][j-1] + 1
		- a[i] != b[j] -> dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i][j])
		- dp[-1][-1] 부터 좌측, 상측, 대각선 확인하면서 DFS로 이동
		- 대각선 방향 DFS 이동 시 현재 글자 경로에 추가 
		- 최종 산출된 경로 리스트를 거꾸로 출력
		- 다른 풀이?
			- 글자가 같아서 dp[i][j] = dp[i-1][j-1] + 1 해주는 부분에 경로를 저장하도록 하는 방식도 써봄
			- 근데 이렇게 되면 실질경로가 아닌 곳도 추가하게 됨.
			- 중복되지 않게 처리하면 되겠지만 귀찮으니 나중에 시간초과가 문제가 되면 써보는 게 좋을 듯. 

	* 경찰차
		- 1차원 DP 방식은 python3 -> 시간초과 / pypy3 -> 메모리 초과
		- DFS로 분할정복을 하는 과정에서 DP를 쓰기만 하고 읽지는 않기 때문에 O(2^n) 시간복잡도
		- 2차원 DP 방식은 통과
			1. 최대한 w*w 크기 안의 DP에 유효값이 모이도록 유도
			2. 경찰차 초기 위치는 튜플 리스트에 연결하는 것이 아니라, 암시적으로 0으로 두고 거리 계산 중에 초기값인지를 판별해서 값을 넣어주는 방식으로 진행
			3. 역추적하는 방법은 점화식 말고는 답이 없었음. 설명도 못하겠네

	* 숨바꼭질 4
		- d[n] : n까지 오는데 걸리는 최소 시간
		- d[n] = min(d[n-1], d[n+1], d[n//2]) + 1
		- d[n] 값이 변하면 주변에 다른 값에도 영향을 주어야 함.
		- 뒤로 가는 방법은 x-1 밖에 없다는 걸 기억해. 제발.

	* DSLR
		- 4가지 연산을 통해서 a 숫자에서 b 숫자로 만드는 연산 최소 사용 횟수 구하는 문제
		- d[n] : 숫자 n을 만들 때 필요한 최소 연산 횟수
		- D 연산 (2*n mod 10000) 때문에 역추적이 불가능함. (5010 D 결과 == 10 D 결과)
		- BFS 중에 연산 사용 로그를 리스트로 남겨서 정답 제출
		- pypy3로 해결

	* 최소비용 구하기 2
		- 다익스트라 알고리즘
			1. 힙큐 사용
			2. 중복 확인 안 함 (dp를 이용해서 값을 누적해가므로 중복된 노드로 이동할 일이 없음)
			3. 그래프를 dict 나 map으로 하면 시간초과가 발생 -> 리스트나 배열로 할 것
			4. 파이썬의 경우 input() 보다 sys.stdin.readline()을 사용해야 함. 

	* 플로이드 2
		- 같은 출발점과 도착점을 가진 간선이 여러 개 일 수 있음. -> 최소값으로 갱신해야 함. 
		- 자기 자신으로 오는 경우는 없음 -> 애초에 최소비용이므로 고려대상도 아님 -> d[wp][wp] = 0
		- 초기값이 float('inf')인 경우 도달 할 수 없다면 0이 아니라 초기값이 출력됨 -> dp 출력 범위 내 한정으로 0으로 바꿔서 출력
		- 플로이드 와샬 알고리즘
			1. 모든 출발점 -> 모든 도착점 최소 비용 구하기
			2. 분할정복 d[i][j] = min(d[i][j], d[i][k] + d[k][j]) k는 경유지
			3. 연산 전에 인접행렬을 dp에 초기화해줘야 함. -> 그래야 분할 정복이 가능
			4. 반복문 세 개로 해결 (경유지, 출발지, 도착지) -> O(n^3) ; DFS, BFS 아님!!
		- 다익스트라 알고리즘으로 해결하려고 하면 오답이 나옴
			- 모든 출발점 고려 시에는 최적해 보장이 안 되는 모양임.
			- 아마 경유지 고려를 안 하기 때문이 아닐까
		- 역추적하는 방법
			1. 경유지 선택 시 해당 경유지를 기록하는 dp와 동일 차원 배열 생성
			2. DFS를 이용해 divide and merge 해서 경로를 생성
			3. path = [start] + tracking(start, end) + [end]
				tracking(start, end) = return tracking(s, w) + [w] + tracking(w, e)
			4. track[i][j] 이 초기값이라면 경유지가 없다는 의미 -> 빈 리스트 반환
			5. 이동하는 경로가 존재하지 않음에도 track만 본다면 경로가 있음으로 판단하므로, dp[i][j] 가 초기값이 아닌지도 함께 확인