⚛️ 백준

	🪄 동적계획법 (Dynamic Programming)

	* 피보나치 수1
		- 재귀호출 피보나치 구현
		- 동적계획 피보나치 구현
		- 재귀호출 부분 시간초과로 제출은 동적계획 코드로만 제출

	* 신나는 함수 실행
		- 3차원 DP 배열 생성
		- 문제 조건에 따라 배열 인덱스가 20 초과이거나 0 이하인 경우에 대해서 전처리하여 exception 해결

	* 01타일
		- 경우의수 셈하여 점화식 생성
		- 피보나치 수열과 유사한 수열
		- d[n] = d[n-2]에 00 붙인 거 + d[n-1]에 1 붙인거 

	* 파도반 수열
		- 문제에 주어진 수열에서 점화식 추출
		- p[n] = p[n-3] + p[n-2]

	* 연속합
		- 정수 수열이 주어졌을때 수열의 연속된 값을 더해서 얻을 수 있는 최대합을 구하는 문제
		- d[n] = max(num[n] + d[n-1], num[n])

	* RGB 거리
		- 문제 자체는 지도 색칠하기 문제랑 비슷한 거 같고, 문제 풀이는 knapsack 문제랑 비슷한 것 같음.
		- i 번째 집과 i-1 번째 집의 색깔이 같지 않도록 모든 집을 칠하는 최소 비용 구하는 문제
		- 2차원 dp 배열을 만듬
		- dp[i][j] : i 번째 집에서 j 색을 칠할 때의 최소비용
		- dp[i][j] = costs[i][j] + min(dp[i-1][j말고 나머지 다])

	* 정수 삼각형
		- 이진트리에서 탐색 경로상 비용이 최대가 되는 경로의 비용 구하는 문제 (이진트리 최대비용 구하기)
		- 입력으로 주어진 삼각형과 동형의 dp 리스트 생성
		- dp[i][j] = triangle[i][j] + max(dp[i+1][j], dp[i+1][j+1])

	* 계단 오르기
		- 한 칸, 두 칸으로만 이동할 수 있는 계단에서 연속 세칸을 밟지 않고서 얻을 수 있는 계단 점수 최대합 구하기
		- dp[n+1][3] 배열 만들어 해결
		- dp[i][1] : 두 칸 건너왔을 때 최대값
		- dp[i][2] : 한 칸 건너왔을 때 최대값
		- dp[i][0] : dp[i][1], dp[i][2] 중 최대값

	* 1로 만들기
		- 정수 x를 
			1. 3으로 나눠떨어지면 //3
			2. 2로 나눠떨어지면 //2
			3. 나머지 -1
			연산으로 1까지 최소 몇 번 연산해야하는지 구하는 문제
		- 6처럼 2, 3 으로 모두 나눠지는 경우랑 -1 하는 경우 중에서 최소가 뭐일지 모르므로 다 넣어줘야 함. 