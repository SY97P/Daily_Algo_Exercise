⚛️ 백준

	🪄 동적계획법 (Dynamic Programming)

	* 피보나치 수1
		- 재귀호출 피보나치 구현
		- 동적계획 피보나치 구현
		- 재귀호출 부분 시간초과로 제출은 동적계획 코드로만 제출

	* 신나는 함수 실행
		- 3차원 DP 배열 생성
		- 문제 조건에 따라 배열 인덱스가 20 초과이거나 0 이하인 경우에 대해서 전처리하여 exception 해결

	* 01타일
		- 경우의수 셈하여 점화식 생성
		- 피보나치 수열과 유사한 수열
		- d[n] = d[n-2]에 00 붙인 거 + d[n-1]에 1 붙인거 

	* 파도반 수열
		- 문제에 주어진 수열에서 점화식 추출
		- p[n] = p[n-3] + p[n-2]

	* 연속합
		- 정수 수열이 주어졌을때 수열의 연속된 값을 더해서 얻을 수 있는 최대합을 구하는 문제
		- d[n] = max(num[n] + d[n-1], num[n])

	* RGB 거리
		- 문제 자체는 지도 색칠하기 문제랑 비슷한 거 같고, 문제 풀이는 knapsack 문제랑 비슷한 것 같음.
		- i 번째 집과 i-1 번째 집의 색깔이 같지 않도록 모든 집을 칠하는 최소 비용 구하는 문제
		- 2차원 dp 배열을 만듬
		- dp[i][j] : i 번째 집에서 j 색을 칠할 때의 최소비용
		- dp[i][j] = costs[i][j] + min(dp[i-1][j말고 나머지 다])

	* 정수 삼각형
		- 이진트리에서 탐색 경로상 비용이 최대가 되는 경로의 비용 구하는 문제 (이진트리 최대비용 구하기)
		- 입력으로 주어진 삼각형과 동형의 dp 리스트 생성
		- dp[i][j] = triangle[i][j] + max(dp[i+1][j], dp[i+1][j+1])

	* 계단 오르기
		- 한 칸, 두 칸으로만 이동할 수 있는 계단에서 연속 세칸을 밟지 않고서 얻을 수 있는 계단 점수 최대합 구하기
		- dp[n+1][3] 배열 만들어 해결
		- dp[i][1] : 두 칸 건너왔을 때 최대값
		- dp[i][2] : 한 칸 건너왔을 때 최대값
		- dp[i][0] : dp[i][1], dp[i][2] 중 최대값

	* 1로 만들기
		- 정수 x를 
			1. 3으로 나눠떨어지면 //3
			2. 2로 나눠떨어지면 //2
			3. 나머지 -1
			연산으로 1까지 최소 몇 번 연산해야하는지 구하는 문제
		- 6처럼 2, 3 으로 모두 나눠지는 경우랑 -1 하는 경우 중에서 최소가 뭐일지 모르므로 다 넣어줘야 함. 

	* 쉬운 계단 수
		- 각 자리수 숫자끼리 1씩 차이나는 숫자를 계단수라고 함.
		- 자리수가 주어졌을 때 존재하는 계단수 구하기
		- dp[i][j] : i번째 자리에 j가 올 경우
		- i-1 번째에 j-1이거나 j+1인 경우 (0, 9 제외)에서 j를 붙인 것임
		- dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]

	* 포도주 시식
		- 계단 오르기 문제와 유사
		- 차이점은 포도주를 안 먹다가 몰아먹을 수 있다는 것
		- wine = [0, 0, 0, 1000, 99, 0, 0] 이런 경우 처음 0은 아예 안 먹어도 됨.
		- dp[i][0] = max(dp[i][1], dp[i][2], dp[i-1][0])

	* 가장 긴 증가하는 부분수열
		- LIS 알고리즘
		- DP로 구하는 방식이랑 bi_sect이용하는 방법 있었던 걸로 기억하는데 bi_sect가 이진탐색 알고리즘이었던 걸로 기억함.
		- 괜히 시간초과 뜰 거 같아서 삽질함
		- 0부터 현재 인덱스-1까지 순회하면서 현재 수보다 작은 dp값 중 최대인 값으로 갱신하면 됨.

	* 가장 긴 바이토닉 부분수열
		- 바이토닉 수열이란 새우등처럼 허리가 위로 솟은 수열을 말함 [1, 2, 5, 2]
		- 쉽게 구하는 방법이 있음
			1. 가장 긴 증가하는 부분수열 DP를 구하고
			2. 가장 긴 감소하는 부분수열 DP를 구하고 (원래 수열을 list(reversed()) 해서 LIS 하면 됨)
		- d_inc[i] + d_dec[i] 최대값이 결과임

	* 전깃줄
		- 그리디로는 풀 수 없는 문제라고 함
		- LIS 기반 문제임
		- 전깃줄이 교차하는 조건은 두 가지 있음
			1. i < j 인데 wire[i] > wire[j] 일 때
			2. i > j 인데 wire[i] < wire[j] 일 때
		- 다시 말해 교차하지 않도록 설치하는 조건은
			i < j 일 때 항상 wire[i] < wire[j] 이면 됨
		- 교차하지 않도록 많이 설치하는 게 LIS 알고리즘
		- 요구 결과는 전깃줄 제거 개수이므로 n - max(dp) 반환


	* LCS (Longest Common Subsequence; 최장 공통 부분수열)
		- 1차원 dp로는 풀 수 없었음
		- 2차원 dp로 풀어야 함. 
			1. 글자길이 + 1 만큼의 2차원 배열 생성 (초기값 : 0)
			2. 글자가 일치 -> dp[i][j] = dp[i-1][j-1] + 1 (지금 글자 없이 만들 수 있는 최대값 + 길이 1)
			3. 글자가 불일치 -> dp[i][j] = max(dp[i-1][j], dp[i][j-1]) (두 문자에서 현재 글자가 어느 한쪽에 없는 상태에서 LCS 최장 길이 중에서 최대값 선택)