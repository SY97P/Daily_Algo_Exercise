⚛️ 백준

	🪄 동적계획법3 (비트마스크 DP)

	* 집합
		- 비트마스크 (2진수)를 써야 풀 수 있는 문제 (메모리초과 방지)
		- 기본 자료형 set을 사용하면 못 품.
		- (1 << 5) -> 0b100000 (뒤에 0 5개)
		- (1 << 5) - 1 -> 0b11111 (1 5개)
		- all : (1 << 20) - 1
		- empty : 0
		- add : s | (1 << x - 1)
		- remove : s & ~(1 << x - 1)
		- check : s & (1 << x - 1) == 0 ? 0 : 1
		- toggle : s ^ (1 << x - 1)

	* 할 일 정하기 1
		- 비트마스크 DP 문제
		- dp[000], dp[001], ..., dp[111]
		- dp[n] : bin(n) 으로 작업을 했을 때 최소 비용
		- dp[i | (1<<j)] = min(dp[i | (1<<j)], dp[i] + d[k-1][j])
		- 현재 기준으로 뒤 DP 값을 갱신하는 이유는 
		- 현재 기준에서의 DP 값 갱신할 때 무조건 DP값을 선택하게 되기 때문

	* 외판원순회
		- 2차원 DP + 비트마스크 + DFS
		- 모든 도시를 순회 (시작도시로 돌아와서 순회 종료)하므로 모든 도시를 출발점으로 고려하지 않아도 됨. (이해 안 됨; 그냥 외우셈)
		- 따라서 0 번째 도시에서 시작한다고 생각하고 다른 모든 방문상태(비트마스크)를 참조해서 최소비용을 구하면 된다. 
		- dp[도시개수][방문상태 비트마스크] = -1 (초기값이 float('inf')가 아닌 이유는 나중에 마지막 도시에서 시작도시로 넘어오는 경로가 없을 경우 무한반복 되기 때문)