⚛️ 백준

	🪄 DP

	* 타일 채우기
	    - d[0] = 1
	    - d[i] = d[i-2]*d[2] + 2 * sum(d[i-4] + ... + d[0])

    * 동전 2
        - n개의 동전 가치로 k 원 만들때 동전 최소 사용수 출력
        - d[i] = min(d[i], d[i-1]+d[1] + d[i-2]+d[2] + ... + d[i//2]+d[i//2+1])

    * 합분해
        - 2차원 DP
        - dp[k][n] : 정수 k개를 사용해서 정수 n을 만드는 경우의 수
        - dp[k][n] = a + b + c (k-1 개) + L(1개) = n 임을 이용
        dp[k][n] = sum(dp[k-1][0] + ... + dp[k-1][n])
                 = dp[k][n-1] + dp[k-1][n]

     * ACMcraft
        - 1차원 DP
        - 방향 그래프
        - root -> W 까지의 경로를 W -> root로의 경로로 변경 (DFS)
        - d[i] : w에서 i 건물 건설까지 걸린 최대 소요시간
               = max(d[i로 들어오는 노드])
        - 메모이제이션
            1. time < dp[node] -> continue
            2. if dp[require] < delay[require] + time -> dp[require] 갱신, 큐 추가

	* 내려가기
		- max_d[i][j] = mat[i][j] + max(max_d[i-1][j-1], max_d[i-1][j], max_d[i-1][j+1])
		- min_d[i][j] = mat[i][j] + min(min_d[i-1][j-1], min_d[i-1][j], min_d[i-1][j+1])

	* 파이프 옮기기1
		- 3차원 DP ([가로, 세로, 대각] n*n 리스트)
		- 맨 첫번째 라인의 가로 dp값을 미리 1로 바인딩해서 처리

		* 시간초과 발생한 풀이
		- 2차원 DP + BFS (시간초과), 2D + DFS(시간초과)
		- deque([(방향;가로/세로/대각, 좌표i, 좌표j)])
		- 가로: A, i, j -> A, i, j+1 / c, i+1, j+1
		- 세로: B, i, j -> B, i+1, j / c, i+1, j+1
		- 대각: C, i, j -> A, i, j+1 / B, i+1, j / C, i+1, j+1
		- 다음 파이프 위상의 좌표에 대해서 outofindex 검사 (0 ~ n-1) 필요
		- 다음 파이프 위상의 좌표에 대해서 빈칸(0)인지 검사

    * 펠린드롬
        - 펠린드롬 : 1 2 1 / 1 / 2 4 1 4 2 같이 대칭인 수열
        - 2차원 DP
            d[i][j] : i번째 수에서 j번째 수까지 부분수열이 펠린드롬인지 여부 (펠린드롬o -> 1 / 펠린드롬x -> 0)
        - 펠린드롬 판별
            - 투포인터
            - a[i] == a[j] -> i += 1, j -= 1 (i >= j 가 될 때까지)
            - a[i] != a[j] -> 펠린드롬 아님

    * 가장 큰 정사각형
        - 2차원 DP
        1. DFS로 DP에 현재 위치 기준 가장 큰 정사각형 크기 저장
        2. DFS 과정에서 주변 4방향 DP값 중 최대인 값이 두 번 이상 나오면 현재 DP값도 최대인 값으로 갱신, continue

    * 1,2,3 더하기
        - 1차원 DP
        - d[i] = d[i-1] + d[i-2] + d[i-3] ('1+'(n-1)만드는 경우의 수 + '2+'(n-2)만드는 경우의 수 + '3+'(n-3)만드는 경우의 수)
        - d = [0, 1, 2, 4]

    * 피보나치 함수
        - fib(0), fib(1) 호출횟수 출력
        - f[i][0] = f[i-1][0] + f[i-2][0]
        - f[i][1] = f[i-1][1] + f[i-2][1]

    * 2xN 타일링
        - d[i] = d[i-2] + d[i-1]
        - d[0], d[1], d[2] = 0, 1, 2