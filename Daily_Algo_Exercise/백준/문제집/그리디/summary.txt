⚛️ 백준

    🪄 그리디 (탐욕법)

    * 거스름돈
        1번 조건. if n >= 10 and (n-10) % 2 == 0 -> 5원 동전 2개 사용
        2번 조건. if n >= 5 and (n-5) % 2 == 0 -> 5원 동전 사용
        3번 조건. if n < 2 or n % 2 != 0 -> break
        4번 조건(default). -> 2원 동전 사용

    * 폴리오미노
        - "AAAA", "BB" 문자열을 이용해서 입력으로 주어진 보드를 채우는 게임
        - "."는 건드리면 안 됨.

    * 로프
        - k개의 로프를 이용해서 최대 얼마의 W를 들 수 있는지 구하는 문제
        1. 로프 정렬
        2. n >= k > 0 -> rope[k] * k

    * 알바생 강호
        - 손님당 얻을 수 있는 팁 = 원래 주려고하는 팁 - (등수 - 1)
        - 얻을 수 있는 팁이 음수이면 받을 수 없는 것 (0원 수령)
        - 손님 순서를 바꿔서 얻을 수 있는 최대 팁 금액

    * ATM

    * 2+1 세일
        - 유제품 3개를 한 번에 사면 가장 싼 하나는 무료로 줌.
        - 3개 미만으로 사면 정가로 구매
        - 물건값을 최소로 낼 때의 필요금액

    * 주유소
        - 결국 중요한 건 거리가 아니라, 현재 최저가임.
        - 최저가만 갱신하면서 진행하면 됨.

    * 에너지 드링크
        - 양이 다른 드링크를 하나의 드링크로 만들 때 만들 수 있는 드링크 최대량
        - 내림차순으로 정렬해서 해도 됨.
        1. 최대힙 (PriorityQueue<Long> * -1)
        2. result = min(result, curr) / 2 + max(result, curr)

    * 서강근육맨
        - 두 운동기구 근손실 합이 최소가 되게 해야함. -> 정렬
        - n이 홀수이면 가장 큰 운동기구만 냅두고 나머지 합쳐서 하기
        - n이 짝수이면 그냥 양 끝단 운동기구 사용하기

    * 블로그2
        1. B묶음, R 묶음 개수 구하기
        2. 두 묶음 중 0인 값이 있으면 1 출력
        3. 두 묶음 중 최대값 출력 (첫 문제랑 마지막 문제가 같은 경우)
        4. 두 묶음 중 최대값 + 1 출력 (첫 문제랑 마지막 문제가 다른 경우)

    * 잃어버린 괄호
        - '-' 가 현재까지 하나라도 있었으면 숫자는 모두 뺄셈 연산
        - '-' 가 현재까지 하나도 없었으면 숫자는 모두 덧셈 연산

    * 민겸수

    * 회의실 배정
        - end <= start -> + 1

    * 강의실 배정
        - end > start -> +1

    * 행복 유치원
        - 인접한 원생들의 키차이 중에서 (n-k)개 작은 것만 덧셈

    * 최소 회의실 개수
        - 강의실 배정 문제랑 같은 거 같은데 왜...?

    * 센서
        1. 오름차순 정렬
        2. 각 원소끼리 차이 구해서 배열화 -> diff
        3. diff 배열 오름차순 정렬
        4. diff 배열 작은 값 n-k개 더하기

    * 배
        1. limit 내림차순 정렬
        2. boxes 내림차순 정렬
        3. boxes 제거하면서 진행

    * 꿀 따기
        - 누적합
        1. 벌벌꿀: 좌 -> sum[n] - v[1] - v[i]
                  우 -> sum[n] - sum[i]
        2. 벌꿀벌: 좌 -> sum[i] - v[1]
                  우 -> sum[n] - sum[i-1] - v[n]
        3. 꿀벌벌: 좌 -> sum[i-1]
                  우 -> sum[n-1] - v[i]

	* 우체국
		* 그리디 방식
			- curr >= (total + 1) // 2 를 만드는 첫 번째 idx
		* 이분탐색
 			- mid 기준 좌측 : sum[mid-1]
					  우측 :	sum[n-1] - sum[mid]
			- 둘 중 큰 쪽으로 left, right을 이동

	* 파일합치기3
		- 우선순위큐
		- 가장 작은 거 두 개 뽑아서 덧셈 후 큐에 다시 추가

	* 크게 만들기
		- 스택 자료구조 이용 (스택 : 출력 결과)
		- 지운 글자수가 k보다 크면 그냥 스택에 추가
		- 지운 글자수가 k보다 작을때 스택의 마지막 숫자보다 현재 숫자가 큰 경우 
			- 지운 글자수가 k보다 작을때까지만 반복하여 스택의 마지막 숫자를 제거
			- 모든 반복 연산 후 현재 글자를 추가해도 n-k개의 글자수를 넘지 않을때 스택에 추가