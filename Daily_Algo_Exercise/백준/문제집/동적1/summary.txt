⚛️ 백준

	🪄 DP

	* 다리 놓기
        - 2차원 DP
        - d[i][j] : 강 서쪽에 i개 사이트, 동쪽에 j개 사이트 있을 때 다리 지을 수 있는 경우의 수
        - d[i][j] = d[i][j-1] + d[i-1][j-1]
        - d[0] = [1,2,3,...,m]
        - d[i][i] = 1

    * 돌 게임
        - d[i]=="SK" -> d[i-1] = d[i-3] = "CY"
        - d[i]=="CY" -> d[i-1] = d[i-3] = "SK"
        - d[n] = "SK"

    * Four Squares
        - d[i] = 1 (i가 제곱수일 때)
        - d[i] = 1 + min(d[i - i이하 제곱수])

    * 동전 2
        - n개의 동전 가치로 k 원 만들때 동전 최소 사용수 출력
        - d[i] = min(d[i], d[i-1]+d[1] + d[i-2]+d[2] + ... + d[i//2]+d[i//2+1])

    * 1,2,3 더하기
        - 1차원 DP
        - d[i] = d[i-1] + d[i-2] + d[i-3] ('1+'(n-1)만드는 경우의 수 + '2+'(n-2)만드는 경우의 수 + '3+'(n-3)만드는 경우의 수)
        - d = [0, 1, 2, 4]

    * 2xN 타일링
        - d[i] = d[i-2] + d[i-1]
        - d[0], d[1], d[2] = 0, 1, 2

    * 2xN 타일링2
        - d[i] = d[i-1] + d[i-2] * 2
        - d[0], d[1], d[2] = 0, 1, 3

    * 가장 긴 증가하는 부분수열
        - LIS DP버전

    * 연속합
        - d[i] = max(a[i], d[i-1]+a[i])
        - i >= 1 !!

    * 가장 큰 증가하는 부분수열
        - LBIS
        - d[i] = max(d[i], d[j] + alist[i]) (0 <= j < i)

    * 가장 긴 짝수 연속한 부분수열(small)
         - 투포인터 (그냥 반복문임;;)
         - 현재 수 기준으로 왼쪽의 수열을 탐색하면서 홀수이면 odd_count 증가, 짝수이면 count 증가
         - odd_count < k 일 때만 연산

    * 스티커
        - 2차원 DP (2차원 수열 때문; 문제해결 로직에 필요한 추가 차원 없음)
        - d[i][j] = s[i][j] + max(d[i][j-2], d[(i+1)%2][j-1], d[(i+1)%2][j-2])

    * 점프
        - 2차원 DP (2차원 매트릭스; 문제해결 로직에 필요한 추가 차원 없음)
        - matrix[i][j] != 0 and dp[i][j] != 0 -> dp[i][j+matrix[i][j]] += dp[i][j], dp[i+matrix[i][j]][j] += dp[i][j]

    * 포도주 시식
        - 2차원 DP
        - d[0][i] : i번째 포도주를 연속하게 마시지 않은 경우 최대량
        - d[1][i] : i번째 포도주를 연속하게 마신 경우 최대량
        - return max(d[-1])