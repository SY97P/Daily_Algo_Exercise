⚛️ 백준

	🪄 DP

	* 다리 놓기
        - 2차원 DP
        - d[i][j] : 강 서쪽에 i개 사이트, 동쪽에 j개 사이트 있을 때 다리 지을 수 있는 경우의 수
        - d[i][j] = d[i][j-1] + d[i-1][j-1]
        - d[0] = [1,2,3,...,m]
        - d[i][i] = 1

    * 돌 게임
        - d[i]=="SK" -> d[i-1] = d[i-3] = "CY"
        - d[i]=="CY" -> d[i-1] = d[i-3] = "SK"
        - d[n] = "SK"

    * Four Squares
        - d[i] = 1 (i가 제곱수일 때)
        - d[i] = 1 + min(d[i - i이하 제곱수])

    * 동전 2
        - n개의 동전 가치로 k 원 만들때 동전 최소 사용수 출력
        - d[i] = min(d[i], d[i-1]+d[1] + d[i-2]+d[2] + ... + d[i//2]+d[i//2+1])

    * 1,2,3 더하기
        - 1차원 DP
        - d[i] = d[i-1] + d[i-2] + d[i-3] ('1+'(n-1)만드는 경우의 수 + '2+'(n-2)만드는 경우의 수 + '3+'(n-3)만드는 경우의 수)
        - d = [0, 1, 2, 4]

    * 2xN 타일링
        - d[i] = d[i-2] + d[i-1]
        - d[0], d[1], d[2] = 0, 1, 2

    * 2xN 타일링2
        - d[i] = d[i-1] + d[i-2] * 2
        - d[0], d[1], d[2] = 0, 1, 3

    * 가장 긴 증가하는 부분수열
        - LIS DP버전

    * 연속합
        - d[i] = max(a[i], d[i-1]+a[i])
        - i >= 1 !!

    * 가장 큰 증가하는 부분수열
        - LBIS
        - d[i] = max(d[i], d[j] + alist[i]) (0 <= j < i)

    * 가장 긴 짝수 연속한 부분수열(small)
         - 투포인터 (그냥 반복문임;;)
         - 현재 수 기준으로 왼쪽의 수열을 탐색하면서 홀수이면 odd_count 증가, 짝수이면 count 증가
         - odd_count < k 일 때만 연산

    * 스티커
        - 2차원 DP (2차원 수열 때문; 문제해결 로직에 필요한 추가 차원 없음)
        - d[i][j] = s[i][j] + max(d[i][j-2], d[(i+1)%2][j-1], d[(i+1)%2][j-2])

    * 점프
        - 2차원 DP (2차원 매트릭스; 문제해결 로직에 필요한 추가 차원 없음)
        - matrix[i][j] != 0 and dp[i][j] != 0 -> dp[i][j+matrix[i][j]] += dp[i][j], dp[i+matrix[i][j]][j] += dp[i][j]

    * 포도주 시식
        - 2차원 DP
        - d[0][i] : i번째 포도주를 연속하게 마시지 않은 경우 최대량
        - d[1][i] : i번째 포도주를 연속하게 마신 경우 최대량
        - return max(d[-1])

    * 쉬운 계단 수
        - d[i][j] : i 자리에 j(0 ~ 9)가 오는 경우의 수
        - d[i][j] = d[i-1][j-1] + d[i-1][j+1]

    * 구간 합 구하기 5
        # 1. 시간초과(64%)
        - d[i][j] : (i, 0) ~ (i, j)까지 구간합
        # 2. 통과
        - d[i][j] : (0, 0) ~ (i, j)까지 구간합
        - d[i][j] = d[i-1][j] + d[i][j-1] - d[i-1][j-1] + matrix[i][j]
        - return d[x2][y2] - d[x2][y1-1] - d[x1-1][y2] + d[x1-1][y1-1]

    * 징검다리 건너기
        - 2차원 DP
        - d[0][i] : 매우 큰 거 안 썼을때 필요 에너지
        - d[1][i] : 매우 큰 거 썼을때 필요 에너지
        - d[0][i+1] = min(self, d[0][i] + small)
        - d[1][i+1] = min(self, d[0][i] + small, d[1][i] + small)
        - d[0][i+2] = min(self, d[0][i] + big)
        - d[1][i+2] = min(self, d[0][i] + big, d[1][i] + big)
        - d[1][i+3] = min(self, d[0][i] + k) -> 매우 큰 거는 한 번만 쓸 수 있음.

    * 징검다리 건너기(small)
         - j * (1 + abs(a[i+j] - a[i])) <= k -> dp[i+j] = true